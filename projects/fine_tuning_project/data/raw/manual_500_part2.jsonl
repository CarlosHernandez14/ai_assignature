{"instruction": "Explica búsqueda binaria sobre función monótona y da un ejemplo de verificación.", "response": "Idea: Buscar el menor x que cumple una condición monótona usando low/high y mid; si se cumple en mid, mueve high=mid, si no, low=mid+1. | Ejemplo: Capacidad mínima de contenedores para enviar paquetes en D días con función puede(C). | Complejidad: O(log R) verificaciones."}
{"instruction": "Da un ejemplo de invariante en un bucle de inserción en ordenamiento por inserción.", "response": "Invariante: Antes de cada iteración i, el subarreglo [0..i-1] está ordenado. | Uso: Mantenerlo insertando key en su posición, desplazando mayores a la derecha. | Prueba: Inicialmente i=1 → trivial; preservación por inserción; al final, arreglo ordenado."}
{"instruction": "Explica por qué quicksort no es estable por defecto.", "response": "Porque durante la partición se pueden intercambiar elementos iguales cambiando su orden relativo. | Soluciones: Partición estable (costo extra) o registrar índices/posiciones. | Implicación: Para ordenar por múltiples claves, usar mergesort o versión estable."}
{"instruction": "Propón una variante de bucket sort y cuándo funciona.", "response": "Variante: Distribuir uniformemente en buckets por rango y ordenar cada bucket con inserción. | Funciona bien cuando los datos en [0,1) están uniformemente distribuidos. | Complejidad esperada: O(n). | Costo: Necesita conocer distribución."}
{"instruction": "Explica counting sort y sus limitaciones.", "response": "Cuenta ocurrencias de cada valor en un rango pequeño, acumula prefijos y coloca establemente. | Complejidad: O(n+K) con K rango de valores. | Limitaciones: K debe ser razonable; requiere memoria O(K). | Uso: Preprocesamiento para radix sort."}
{"instruction": "Describe radix sort LSD y cuándo preferirlo.", "response": "Ordena dígito a dígito desde el menos significativo usando counting sort estable. | Ventaja: O(d·(n+K)) para d dígitos; útil cuando d es pequeño y K limitado. | Uso: Enteros de ancho fijo, strings cortos. | Requisito: Estabilidad en la pasada."}
{"instruction": "Compara BFS con 0-1 BFS.", "response": "0-1 BFS usa deque: peso 0 → push_front, peso 1 → push_back; obtiene distancias mínimas en grafos con pesos 0/1. | BFS normal asume costo uniforme por arista. | Complejidad: O(V+E). | Ventaja: Evita Dijkstra en pesos 0/1."}
{"instruction": "Explica Dijkstra con decrease-key versus push duplicado.", "response": "Decrease-key reduce clave en heap (mejor complejidad teórica). | En práctica, se usa push duplicado y se ignoran entradas obsoletas al extraer (más simple y rápido). | Correctitud: Se valida dist actual antes de procesar."}
{"instruction": "Explica por qué Bellman-Ford requiere V-1 iteraciones.", "response": "Cada iteración relaja caminos con a lo sumo k aristas; tras V-1, se han considerado todos los caminos simples (a lo sumo V-1 aristas). | Iteración extra detecta ciclos negativos si aún mejora."}
{"instruction": "Da un ejemplo de heurística inconsistente en A* y el efecto.", "response": "Si h viola h(u) ≤ c(u,v)+h(v), f puede decrecer y A* podría reabrir nodos, perdiendo eficiencia; aún encuentra óptimo si h es admisible, pero puede expandir mucho más."}
{"instruction": "Define árbol k-ario heap y pros/contras.", "response": "Heap d-ario reduce altura (log_d n), menos extracciones, pero aumenta comparaciones por extracción. | Pros: Menos niveles → menos disminuciones. | Contras: Sift-down más costoso. | Uso: D mayor para muchas inserciones."}
{"instruction": "Explica por qué un BST degenerado tiene O(n).", "response": "Si se inserta en orden, el árbol se vuelve una lista; altura = n-1; operaciones de búsqueda/insert/borrar se vuelven O(n). | Solución: Usar balanceados (AVL, rojo-negro) o aleatorizar."}
{"instruction": "Compara AVL vs rojo-negro.", "response": "AVL más estricto en balance → búsquedas más rápidas en promedio; rojo-negro más simple para inserciones/borrados con menos rotaciones. | Ambos garantizan O(log n)." }
{"instruction": "Define heap-indexado y caso de uso.", "response": "Heap con acceso por índice de elemento (posición en heap) para soportar decrease-key eficiente. | Uso: Dijkstra clásico con decrease-key real. | Estructura: Heap + mapa id→pos."}
{"instruction": "Explica por qué Union-Find con union por rango y compresión es casi O(1).", "response": "La complejidad amortizada es O(α(n)) con α(n) inversa de Ackermann, que crece lentísimo; en práctica constante. | Clave: Comprimir caminos y unir árbol pequeño debajo del grande."}
{"instruction": "Describe DSU rollback y uso.", "response": "Versión de Union-Find que permite deshacer uniones guardando cambios en una pila. | Uso: Offline queries con divide & conquer y rangos de tiempo. | Costo: O(log n) por cambios aplicados/ revertidos."}
{"instruction": "Explica por qué topological sort falla si hay ciclo.", "response": "En Kahn, no habrá suficientes nodos de in-degree 0 para procesar todos; la cola se vacía antes de contar V nodos. | En DFS, aparece una arista de retroceso (a un gris)."}
{"instruction": "Compara recorridos de árboles: inorden, preorden, postorden.", "response": "Inorden: izquierda, nodo, derecha (BST produce orden). | Preorden: nodo, hijos (útil para copiar/serializar). | Postorden: hijos, nodo (borrado/liberar o evaluar expresiones)."}
{"instruction": "Explica por qué LIS O(n log n) no da la secuencia sin rastreo.", "response": "Mantiene solo 'tails' mínimos; para reconstruir, hay que guardar predecesores e índices elegidos por cada posición. | Sin eso, solo obtienes la longitud."}
{"instruction": "Define DAG shortest path con pesos negativos.", "response": "Es posible en O(V+E) si se hace orden topológico y relajación; pesos negativos no causan ciclos en DAG. | Útil cuando el grafo es acíclico por diseño (dependencias)."}
{"instruction": "Explica multi-source BFS y un ejemplo.", "response": "Inicializar la cola con múltiples nodos fuente (dist=0) y expandir simultáneamente. | Ejemplo: Distancia a la celda más cercana con 1 en una grilla. | Complejidad: O(V+E)."}
{"instruction": "Explica por qué Floyd-Warshall permite reconstrucción de camino.", "response": "Al mantener una matriz next[i][j] con el primer salto en el camino mínimo y actualizarla al mejorar dist[i][j], se puede reconstruir el camino completo."}
{"instruction": "Compara complejidad de mergesort linked list vs arreglo.", "response": "En listas, mergesort es natural y puede ser O(1) extra al intercalar nodos; en arreglos requiere O(n) extra. | Quicksort en listas es menos eficiente por partición difícil."}
{"instruction": "Explica por qué la mediana minimiza suma de distancias L1.", "response": "En 1D, la función suma |x - a_i| es convexa por tramos y su mínimo se logra en cualquier mediana. | Intuición: Derivada cambiante por puntos a izquierda/derecha."}
{"instruction": "Describe el algoritmo de Moore para mayoría (>n/2).", "response": "Mantén un candidato y un contador; incrementa si coincide, decrementa si no; al final, verificar si realmente es mayoría. | Complejidad: O(n), O(1) espacio."}
{"instruction": "Explica por qué KMP es lineal incluso con patrones repetitivos.", "response": "Porque al fallar, usa pi para saltar posiciones del patrón sin retroceder en el texto; cada carácter del texto se procesa a lo sumo dos veces."}
{"instruction": "Describe el truco de 'dos BFS' en árboles para diámetro y centro.", "response": "BFS desde arbitrario → A; BFS desde A → B; camino A-B es diámetro; el centro es el nodo medio de ese camino (1 o 2 nodos)."}
{"instruction": "Explica edición con transposición (Damerau-Levenshtein).", "response": "Permite operaciones de inserción, borrado, sustitución y transposición de adyacentes; DP ampliada con memoria de posiciones. | Útil en corrección tipográfica."}
{"instruction": "Describe cómo detectar articulaciones (puntos de corte).", "response": "DFS con tiempos de entrada y low-link; un nodo u es articulación si tiene hijo v con low[v] ≥ tin[u] (o raíz con ≥2 hijos). | Tarjan para low-link."}
{"instruction": "Explica puentes en grafos y su detección.", "response": "Arista (u,v) es puente si low[v] > tin[u] en DFS; al eliminarla, aumenta componentes. | Se calcula en O(V+E)."}
{"instruction": "Explica por qué hashing de strings usa potencia modular.", "response": "Para permitir hash rodante H = Σ s[i]·p^i mod M; mover ventana actualiza en O(1) eliminando el término que sale y multiplicando por p."}
{"instruction": "Discute dos módulos y dos bases para reducir colisiones en Rabin-Karp.", "response": "Usar doble hash con distintos primos y bases minimiza probabilidad de colisiones coincidentes; verifica ambos antes de confirmar match."}
{"instruction": "Explica búsqueda en matrices ordenadas por filas y columnas.", "response": "Desde la esquina superior derecha: si actual > x baja, si < x avanza a la derecha; O(n+m). | Alternativa: binaria por fila (si se sabe rango)." }
{"instruction": "Explica por qué 'two-sum' con set funciona y posibles fallas.", "response": "Se guarda complementos; al ver a[i], si está en set, se encontró par; si no, añade (target - a[i]). | Fallas: Duplicados y necesidad de índices; cuidado al construir solución."}
{"instruction": "Explica sliding window con conteo de caracteres para anagramas.", "response": "Mantén frecuencias en ventana; al mover, actualiza; cuando coinciden con patrón, anagrama encontrado. | Complejidad: O(n + α) con α alfabeto."}
{"instruction": "Compara 'next greater element' y 'next smaller element'.", "response": "Ambos con pila monótona; para NGE, pila decreciente; para NSE, pila creciente. | Aplicación: histogramas, temperaturas, stock span."}
{"instruction": "Describe DP para 'palíndromo mínimo por inserciones'.", "response": "DP[i][j] = min inserciones para hacer palíndromo A[i..j]; si A[i]==A[j], dp=dp[i+1][j-1], si no, 1+min(dp[i+1][j],dp[i][j-1])."}
{"instruction": "Explica por qué en knapsack 0/1 1D se itera w descendente.", "response": "Para no reutilizar el mismo objeto varias veces; si se hiciera ascendente, dp[w] usaría dp[w-weight] ya actualizado en esta ronda."}
{"instruction": "Explica 'meet-in-the-middle' en subset sum.", "response": "Divide conjunto en dos mitades, genera sumas de cada mitad, ordena una y busca complementos por binaria; O(2^(n/2) log). | Útil para n≈40."}
{"instruction": "Define 'offline queries' con ordenamiento por bloque (Mo's algorithm).", "response": "Reordenar queries por bloques de tamaño ~√n y ordenar por bloque y R; mover L y R con actualizaciones O(1) amortizadas. | Útil en queries de rango estáticas."}
{"instruction": "Explica por qué DP en cuadrícula usa base 'primera fila/columna'.", "response": "Son rutas únicas al avanzar solo derecha/abajo; base permite construir el resto por recursión: ways[i][j] = ways[i-1][j] + ways[i][j-1]."}
{"instruction": "Explica selección aleatoria del pivote y su efecto.", "response": "Reduce probabilidad de peores casos en quicksort/quickselect; caso esperado O(n log n)/O(n). | CUIDADO: Semilla para reproducibilidad."}
{"instruction": "Describe 'reservoir sampling' para streaming.", "response": "Mantén k muestra de un stream de tamaño desconocido; cada nuevo elemento i se toma con prob k/i reemplazando al azar. | Garantiza uniformidad."}
{"instruction": "Explica por qué el método de barrido necesita orden de eventos consistente.", "response": "Ties: Procesar primero finales y luego inicios evita contar solapes dobles según definición; la convención afecta el resultado."}
{"instruction": "Explica mergesort externo (external sort).", "response": "Divide archivo en runs que caben en memoria, ordénalos, escribe; luego mezcla k-way en múltiples fases. | Uso: Datos que no caben en memoria. | I/O optimizado."}
{"instruction": "Compara Arreglo vs Lista enlazada para operaciones comunes.", "response": "Arreglo: index O(1), inserciones/borrados en medio O(n). | Lista: inserciones/borrados O(1) dado nodo, index O(n). | Elección depende del patrón de acceso."}
{"instruction": "Explica por qué un trie comprimido (radix tree) ahorra memoria.", "response": "Combina cadenas de nodos con único hijo en un solo arco etiquetado por subcadena; menos nodos y punteros, misma lógica de prefijos."}
{"instruction": "Describe cómo implementar un 'autocomplete' eficiente con un trie.", "response": "Navegar al nodo de prefijo y hacer DFS limitado para recolectar k sugerencias; almacenar top-k en cada nodo acelera consultas (precomputado)."}
{"instruction": "Explica DP de edición con costo de operaciones diferentes.", "response": "La transición general: min(deleción + cost_del, inserción + cost_ins, sustitución + cost_sub), con una matriz dp; basta ajustar los costos por operación."}
{"instruction": "Define grafo bipartito y un criterio con matching máximo.", "response": "Un grafo es bipartito si no tiene ciclos impares; además, König: tamaño del matching máximo = tamaño del vertex cover mínimo en bipartitos."}
{"instruction": "Explica Kuhn y Hopcroft–Karp para matching bipartito.", "response": "Kuhn: DFS para augmenting paths O(VE). | Hopcroft–Karp: BFS capas + múltiples DFS, O(E√V). | Elegir según tamaño del grafo."}
{"instruction": "Explica por qué Johnson usa potencias h para reponderar.", "response": "h(v) asegura que w'(u,v) = w(u,v) + h(u) - h(v) ≥ 0 y preserva diferencias de pesos de caminos; Dijkstra aplica en w' sin negativos."}
{"instruction": "Define aristas críticas en MST y cómo detectarlas.", "response": "Arista crítica aparece en todo MST; con Kruskal, si es la única con ese peso que cruza cierto corte, es crítica. | Se prueba quitando/forzando la arista."}
{"instruction": "Explica DP para cadenas con patrón wildcard '?', '*'.", "response": "dp[i][j] verdadero si patrón[0..j] matchea texto[0..i]; '?' consume uno, '*' consume cero o más: dp[i][j] = dp[i][j-1] o dp[i-1][j]."}
{"instruction": "Describe automata Aho–Corasick.", "response": "Trie de patrones + fallos estilo KMP para saltar al siguiente prefijo; permite buscar múltiples patrones en O(n + matches). | Construcción O(sum longitudes)."}
{"instruction": "Explica por qué Z-algorithm es útil en 'pattern in text'.", "response": "Concatena patrón '$' texto; Z[i] igual a longitud de prefijo que coincide → si Z ≥ |patrón| en alguna posición, hay match. | O(n)."}
{"instruction": "Compara DP y greedy en 'jump game'.", "response": "Greedy desde la izquierda manteniendo el alcance máximo es O(n) y suficiente; DP también funciona pero es innecesario. | Pitfall: casos límite con ceros."}
{"instruction": "Explica por qué 'interval scheduling' general con pesos requiere DP.", "response": "Con pesos, greedy por fin no funciona; se usa DP con p(i) (último compatible): dp[i]=max(dp[i-1], w_i+dp[p(i)]). | Ordenar por fin."}
{"instruction": "Define aristas de árbol, de avance, de retroceso y cruzadas en DFS.", "response": "Árbol: visitadas por primera vez; avance: a descendiente; retroceso: a ancestro; cruzadas: entre subárboles diferentes (en grafos dirigidos)."}
{"instruction": "Explica el 'low-link' y su significado.", "response": "low[u] = mínimo tin alcanzable desde u incluyendo retrocesos; permite detectar puentes (low[v] > tin[u]) y articulaciones."}
{"instruction": "Explica 'binary lifting' para k-ésimo ancestro.", "response": "Precompute up[u][j] = 2^j-ésimo ancestro; para subir k, descomponer en bits y mover. | Complejidad: O(n log n) preprocess, O(log n) por consulta."}
{"instruction": "Da un ejemplo de 'rolling median' con dos heaps.", "response": "Heap máx para menores, heap mín para mayores; rebalancear cuando difieren en más de 1; mediana es top del heap mayor (o promedio si balanceado)."}
{"instruction": "Explica por qué 'distinct subarrays by modulo' usa pigeonhole.", "response": "Si hay n números, los n prefijos mod n repiten un residuo → existe un subarreglo con suma múltiplo de n; prueba por principio del palomar."}
{"instruction": "Explica 'prefix function' en strings y un uso adicional a KMP.", "response": "Pi permite hallar periodos de la cadena: n - pi[n-1] si divide n; útil para compresión y mezcla de cadenas repetitivas."}
{"instruction": "Explica trie con conteo de pasadas para borrar seguro.", "response": "Guarda contador de cuántas palabras pasan por cada nodo y cuántas terminan; al borrar, decrementa y elimina nodos con contador 0."}
{"instruction": "Describe 'disjoint set of intervals' y estructura adecuada.", "response": "Mantener intervalos disjuntos con mapa ordenado; al insertar, fusionar con vecinos que solapan; consultas de pertenencia por lower_bound."}
{"instruction": "Explica 'convex hull trick' en DP lineal.", "response": "Para dp[i] = min_j (m_j x_i + b_j), mantener envolvente de rectas en estructura monotónica; consultas en O(1)/O(log n) según patrón."}
{"instruction": "Define 'sparse table' y uso.", "response": "Precompute RMQ con potencias de dos; query en O(1) y O(n log n) preprocess; inmutable (no soporta updates). | Uso: min/max idempotentes."}
{"instruction": "Explica 'segment tree beats' (visión general).", "response": "Segment tree avanzado que soporta operaciones como chmin/chmax y sum con podas; mantiene info extra y lazy; complejo pero potente."}
{"instruction": "Explica por qué 'probing lineal' requiere factor de carga controlado.", "response": "Clustering primario degrada rendimiento a medida que la tabla se llena; mantener load factor < 0.7 y usar doble hashing/quadratic ayuda."}
{"instruction": "Compara 'quadratic probing' con 'double hashing'.", "response": "Quadratic reduce clustering primario pero puede fallar en visitar todas las celdas; double hashing usa segundo hash y recorre toda la tabla."}
{"instruction": "Explica 'order statistics tree' y operaciones.", "response": "BST balanceado con tamaño de subárbol para seleccionar k-ésimo o rank; soporta insert/borrar/buscar/rank/select en O(log n)."}
{"instruction": "Explica 'Treap' y su beneficio.", "response": "Combina BST por clave y heap por prioridad aleatoria; balance esperado O(log n); código simple, rotaciones basadas en prioridad."}
{"instruction": "Explica 'Splay tree' y cuándo conviene.", "response": "Autoajustable, mueve elemento accedido a la raíz; garantiza costo amortizado O(log n); bueno para accesos con localidad temporal."}
{"instruction": "Describe 'rope' para cadenas grandes.", "response": "Árbol balanceado con hojas como fragmentos; concat, split, substring en O(log n); útil en editores de texto."}
{"instruction": "Explica 'union by size' versus 'by rank'.", "response": "Por tamaño une árbol pequeño bajo el grande; por rango usa estimación de altura; ambos logran amortizado casi O(1) con compresión."}
{"instruction": "Explica 'Kahn con prioridades' para orden topológico lexicográfico mínimo.", "response": "Usar heap/priority queue en lugar de cola para extraer el menor elemento disponible; mantiene orden lexicográfico mínimo."}
{"instruction": "Explica por qué 'tarjan SCC' usa pila y lowlink.", "response": "Pila para mantener el componente actual; lowlink detecta raíz de SCC cuando low[u]==tin[u], desempila hasta u para formar la SCC."}
{"instruction": "Define '2-SAT' y su resolución con SCC.", "response": "Construir grafo de implicación; si x y ¬x están en la misma SCC, insatisfacible; orden topológico de SCC da asignación. | O(V+E)."}
{"instruction": "Explica 'articulation bridges en 2D grid' y aplicación.", "response": "Modela celdas como nodos y aristas por adyacencia; puentes/ articulaciones señalan cuellos de botella; útil en mapas/juegos."}
{"instruction": "Explica por qué Kadane sirve para todos negativos.", "response": "Inicializa best_end y best al primer elemento; así el máximo subarreglo puede ser el mayor (menos negativo) elemento individual."}
{"instruction": "Explica 'maximum rectangle in histogram' con pila.", "response": "Mantener pila de índices con alturas crecientes; al ver menor altura, desapilar calculando áreas con la altura desapilada como mínima."}
{"instruction": "Explica 'largest rectangle of 1s' en matriz.", "response": "Convierte cada fila en histogramas acumulando alturas de 1s y aplica el algoritmo del histograma en cada fila; O(R·C)."}
{"instruction": "Describe 'two-pointer' en array circular (subarrays con producto < K).", "response": "Ventana deslizante multiplicativa expandiendo y contrayendo; cuenta subarreglos al agregar cada elemento; cuidado con ceros."}
{"instruction": "Explica por qué 'median of two sorted arrays' requiere partición válida.", "response": "Condición max(leftA,leftB) ≤ min(rightA,rightB); garantiza que la mediana está en los bordes de la partición combinada."}
{"instruction": "Explica 'covering intervals con mínimo de puntos'.", "response": "Greedy: Ordena por fin y coloca un punto al final del primer intervalo, elimina los cubiertos, repite. | Correctitud: Prueba de intercambio."}
{"instruction": "Explica el 'activity selection con recursos múltiples' y complejidad.", "response": "Caso general es NP-duro; variantes se resuelven con flujos o DP; greedy simple no basta con múltiples recursos."}
{"instruction": "Describe 'max flow' con Edmonds–Karp.", "response": "BFS por capas encuentra camino aumentante más corto en aristas; O(VE^2). | Correctitud: Invariantes de corte mínimo/flujo máximo."}
{"instruction": "Explica 'Dinic' y por qué es más rápido.", "response": "Construye 'level graph' y encuentra bloqueos con DFS; complejidad O(EV^2), mejor en práctica; para redes unitarias O(min{E^{1/2},V^{2/3}}E)."}
{"instruction": "Explica 'Min-Cost Max-Flow' con potentials.", "response": "Usa Dijkstra con potenciales para manejar pesos negativos entre iteraciones; repondera para evitar negativos; incrementa flujo con costo mínimo."}
{"instruction": "Explica 'bipartite matching' como flujo.", "response": "Modelar bipartito con fuente conectada a U y V al sumidero, capacidades 1; matching máximo = flujo máximo. | Integridad por capacidades enteras."}
{"instruction": "Define 'corte mínimo' y relación con flujo máximo.", "response": "Teorema max-flow min-cut: valor del flujo máximo = capacidad del corte mínimo; corte biparticiona nodos; identifica cuellos de botella."}
{"instruction": "Explica 'Kruskal con DSU' para MST y manejo de aristas iguales.", "response": "Ordena por peso; en ties, el orden no importa mientras se eviten ciclos; DSU garantiza componentes; resultado puede no ser único."}
{"instruction": "Explica 'Prim con heap' para MST en grafo denso vs disperso.", "response": "En densos, matriz + O(V^2) puede ser mejor; en dispersos, lista + heap O(E log V) es preferible. | Elegir estructura adecuada."}
{"instruction": "Explica por qué 'binary lifting' requiere raíz y preprocesamiento DFS.", "response": "Se necesitan profundidades y ancestros directos por DFS/BFS; desde ellos se rellenan las potencias de dos iterativamente."}
{"instruction": "Describe 'RMQ con sparse table' y por qué es O(1).", "response": "Precomputa min de bloques 2^k; una query [l,r] se contesta con dos bloques que cubren el rango; función idempotente permite esto."}
{"instruction": "Explica 'Cartesian tree' y su relación con RMQ/LCA.", "response": "Árbol donde inorden da el arreglo y heap por valores; RMQ en arreglo = LCA en el árbol; útil para transformaciones de problemas."}
{"instruction": "Explica 'suffix array' a alto nivel.", "response": "Arreglo de índices de sufijos ordenados lexicográficamente; permite búsqueda binaria de patrones; construcción O(n log n) o O(n)."}
{"instruction": "Describe 'LCP array' y cómo se usa.", "response": "LCP[i] = longitud del prefijo común entre sufijos SA[i] y SA[i-1]; útil para contar substrings distintas y compresión."}
{"instruction": "Explica 'Kasai' para construir LCP en O(n).", "response": "Usa rank inverso y reusa la coincidencia anterior disminuyendo en 1 por paso; compara sufijos adyacentes en SA sin reiniciar."}
{"instruction": "Explica 'Z vs prefix-function' diferencias prácticas.", "response": "Z compara contra prefijo global; pi compara prefijos de la cadena consigo misma; según el problema, uno resulta más directo."}
{"instruction": "Explica 'bitset DP' para subset sum.", "response": "Usar bitset donde bit x indica suma alcanzable; por cada número a, desplazar bitset a la izquierda y OR; rápido con operaciones a nivel de palabra."}
{"instruction": "Explica 'SOS DP' para sums over subsets.", "response": "Transformación que acumula valores para todos los superconjuntos/subconjuntos; O(n·2^n) sobre n bits; útil en conteos por máscara."}
{"instruction": "Explica 'digit DP' a alto nivel.", "response": "DP por posiciones de dígito con restricciones (límite, lleva, propiedades); estados (pos, tight, ...); recorre de MSB a LSB."}
{"instruction": "Explica 'Knuth optimization' (visión general).", "response": "Optimiza DP cuadrática con cuadrang. si se cumple monotonicidad de argmin; reduce a O(n^2). | Ej: DP de particionado óptimo."}
{"instruction": "Explica 'Divide & Conquer DP optimization'.", "response": "Si argmin es monotónico, la DP de costes separables se resuelve en O(n log n) por nivel; requiere estructura de convexe/monotónica."}
{"instruction": "Explica 'SMAWK' para matrices totalmente monótonas.", "response": "Algoritmo que halla mínimos de cada fila en O(n); usa monocidad total para reducir columnas y recursión; avanza con filtrado."}
{"instruction": "Explica 'Euler tour + segment tree' para path queries en árboles.", "response": "Mapea subárboles a rangos contiguos por tiempos de entrada; segment tree/fenwick responden sumas/min en subárboles."}
{"instruction": "Explica 'Heavy-Light Decomposition' (visión general).", "response": "Descompone árbol en caminos heavy y light para convertir path queries a O(log^2 n) sobre estructuras de rango."}
{"instruction": "Explica 'centroid decomposition' y uso.", "response": "Divide árbol por centroides para resolver queries globales con DP por niveles; útil en distancias y problemas de cobertura."}
{"instruction": "Explica 'binary search on tree answer' (k-th in path).", "response": "Usar HLD + estructuras ordenadas/fenwick por valor y binaria sobre respuesta; o persistent segment trees en Euler Tour."}
{"instruction": "Explica 'persistent segment tree' y caso de uso.", "response": "Versionado inmutable de segment tree permitiendo queries en versiones pasadas; útil para k-th menor en prefijo o histórico."}
{"instruction": "Explica por qué 'Fenwick' puede extenderse a 2D.", "response": "BIT 2D mantiene sumas por rectángulo con actualizaciones punto; complejidad O(log^2 n); índices 1-based y combinaciones de bits."}
{"instruction": "Explica 'offline range add + point query' con diferencia y prefix.", "response": "Aplicar todas actualizaciones a un diff y luego hacer prefijos; para queries puntuales, basta leer prefijo en la posición."}
{"instruction": "Explica 'range add + range sum' con dos BITs.", "response": "Mantén BIT B1 y B2; suma en rango actualiza ambos; query de prefijo usa combinación prefix(x)=x*sum(B1)-sum(B2)."}
{"instruction": "Explica 'Mo con updates' (tres dimensiones).", "response": "Extiende Mo con una tercera dimensión tiempo; mantener estructura al mover L, R y aplicar/revertir actualizaciones; más complejo y lento."}
{"instruction": "Explica 'sliding window máximo' con heap lazy.", "response": "Mantener heap de valores con índices; al mover, descartar perezosamente los que salieron de ventana; más simple pero O(log n) por paso."}
{"instruction": "Explica 'two-pointer' para triángulos válidos en un arreglo.", "response": "Ordenar; para cada k, usar i=0,j=k-1 y contar pares con a[i]+a[j]>a[k]; mover punteros adecuadamente; O(n^2)."}
{"instruction": "Explica 'three-sum' con dos punteros.", "response": "Ordenar y para cada i, resolver 2-sum en [i+1..] con two pointers; saltar duplicados; O(n^2)."}
{"instruction": "Explica 'four-sum' y por qué usar hash de pares.", "response": "Guardar sumas de pares y combinarlas con otras sumas para target; cuidado con duplicados; O(n^2) espacio/tiempo."}
{"instruction": "Explica 'min window substring' idea.", "response": "Ventana deslizante con conteos requeridos; expande hasta cumplir, contrae manteniendo validez; guarda mejor longitud; O(n)."}
{"instruction": "Explica 'longest repeating character replacement'.", "response": "Ventana deslizante con frecuencia máxima en ventana; mantener condición ventana_len - max_freq ≤ k; expandir/contraer; O(n)."}
{"instruction": "Explica 'car pooling' (posible plan) con diferencia.", "response": "Convertir viajes a +capacidad en inicio y -capacidad en fin; ordenar eventos; acumular pasajeros y verificar no exceder cap."}
{"instruction": "Explica 'merge intervals' y error común.", "response": "Ordenar por inicio; fusionar solapes; error común: no considerar igualdad (start ≤ fin) como solape; O(n log n)."}
{"instruction": "Explica 'insert interval' correctamente.", "response": "Añadir nuevo intervalo y fusionar con vecinos; mantener orden; al final, consolidar; O(n)."}
{"instruction": "Explica 'course schedule' como ciclo en DAG.", "response": "Problema de prerequisitos es detectar ciclo en grafo dirigido; usar Kahn o DFS; si no se procesan todos, hay ciclo."}
{"instruction": "Explica 'evaluate division' con grafo ponderado.", "response": "Representar ecuaciones a/b=k como aristas ponderadas; query es producto de pesos en camino; usar DFS/BFS con multiplicación."}
{"instruction": "Explica 'reconstruct itinerary' con Hierholzer.", "response": "Construir circuito euleriano lexicográfico con multigrafo; usar pila para backtracking; resultado invertido; O(E log E) por ordenamiento."}
{"instruction": "Explica 'alien dictionary' como topológico.", "response": "Derivar orden parcial comparando pares de palabras y la primera diferencia; construir grafo y hacer topological sort; detectar inconsistencias."}
{"instruction": "Explica 'word ladder' con BFS bidireccional.", "response": "BFS desde inicio y fin, expandiendo la frontera más pequeña; genera patrones con comodines para vecinos; mejora sobre BFS simple."}
{"instruction": "Explica 'trie + DFS' para 'word search' en tablero.", "response": "Usar trie de palabras; DFS en la grilla siguiendo letras; marcar visitado temporalmente; poda al no encontrar prefijos."}
{"instruction": "Explica 'serialize/deserialize' de árbol binario (nivel).", "response": "Nivel con nulls para hijos faltantes; deserializar leyendo en orden y asignando hijos con una cola; robusto a árboles no completos."}
{"instruction": "Explica 'lowest common ancestor' en BST simple.", "response": "Desde la raíz, si ambos < root, ir izquierda; si ambos > root, derecha; si divergen, root es LCA; O(h)."}
{"instruction": "Explica 'lowest common ancestor' en árbol general con binary lifting.", "response": "Elevar el más profundo para igualar profundidades y luego subir ambos por potencias de dos hasta que sus padres coincidan; O(log n)."}
{"instruction": "Explica 'serialize/deserialize' por preorden con marcadores.", "response": "Preorden incluyendo marcadores '#' para null; deserializar leyendo secuencia recursivamente; reconstruye estructura exacta."}
{"instruction": "Explica 'unique paths II' con obstáculos.", "response": "DP en grilla evitando celdas con obstáculo (ways=0); base primera fila/col se resetea ante obstáculos; O(R·C)."}
{"instruction": "Explica 'trapping rain water' con dos punteros.", "response": "Mantener maxLeft y maxRight; mover puntero de menor altura acumulando agua local; O(n), O(1) espacio."}
{"instruction": "Explica 'rotate image' (matriz NxN).", "response": "Transponer y luego invertir cada fila (o capas por anillos); O(n^2) tiempo, in-place."}
{"instruction": "Explica 'spiral matrix' de extracción.", "response": "Mantener límites top, bottom, left, right; recorrer bordes y ajustar límites; repetir mientras top ≤ bottom y left ≤ right."}
{"instruction": "Explica 'set matrix zeroes' in-place con primera fila/columna.", "response": "Usar primera fila/col como marcadores de ceros; bandera para primera fila/col; segunda pasada para cero-ficar; O(1) extra."}
{"instruction": "Explica 'valid sudoku' comprobando reglas.", "response": "Usar sets por fila, columna y subcuadro 3x3; verificar duplicados al leer; O(81)."}
{"instruction": "Explica 'subsets II' (con duplicados) backtracking.", "response": "Ordenar y saltar duplicados cuando no se tomó el anterior; generar con decisión incluir/no incluir; evita repetidos."}
{"instruction": "Explica 'permutations II' (con duplicados) backtracking.", "response": "Usar contador de ocurrencias por valor; elegir valores con count>0, decrementar y backtrack; evita duplicados naturalmente."}
{"instruction": "Explica 'restore IP addresses' backtracking.", "response": "Probar cortes de 1 a 3 dígitos validando rango y ceros a la izquierda; 4 segmentos exactos; poda por longitud restante."}
{"instruction": "Explica 'palindrome partitioning' backtracking + DP.", "response": "Precomputar palíndromos por DP; backtracking para cortes usando tabla; reduce costo de verificación."}
{"instruction": "Explica 'generate parentheses' con conteo.", "response": "Backtracking con dos contadores: abiertos restantes y cerrados disponibles; nunca cerrar más de lo abierto; generar bien formadas."}
{"instruction": "Explica 'N-Queens' con bitmasks.", "response": "Usar máscaras para columnas, diag1, diag2; en cada fila, tomar posiciones válidas como bits y recursar; muy eficiente."}
{"instruction": "Explica 'edit distance' espacio O(min(n,m)).", "response": "Guardar solo la fila anterior y la actual; actualizar células en orden; reduce memoria de O(nm) a O(min(n,m))."}
{"instruction": "Explica 'shortest common supersequence' relación con LCS.", "response": "SCS(A,B) = |A| + |B| - LCS(A,B); para reconstruir, mezclar respetando LCS común y agregando caracteres restantes."}
{"instruction": "Explica 'min insertions to palindrome' como n - LPS.", "response": "LPS (longest palindromic subsequence); mínimo de inserciones = n - LPS; LPS por LCS(s, reverse(s))."}
{"instruction": "Explica 'house robber' DP simple.", "response": "dp[i]=max(dp[i-1], dp[i-2]+nums[i]); base dp[0]=nums[0], dp[1]=max(nums[0],nums[1]); O(n) tiempo, O(1) espacio si se comprime."}
{"instruction": "Explica 'circular house robber'.", "response": "Resolver robando [0..n-2] y [1..n-1] por separado y tomar el máximo; evita tomar primero y último juntos."}
{"instruction": "Explica 'coin change ways' (número de formas).", "response": "DP 1D con sumas: dp[0]=1; para cada moneda, para x de coin..target, dp[x]+=dp[x-coin]; orden por monedas evita permutaciones."}
{"instruction": "Explica 'partition equal subset sum'.", "response": "Subset sum al objetivo total/2 con bitset o DP booleana; si bit objetivo es 1, es posible; cuidado con suma impar."}
{"instruction": "Explica 'combination sum' backtracking con repetición.", "response": "Ordenar candidatos; permitir reutilizar mismo índice; podar cuando excede target; evitar duplicados con orden."}
{"instruction": "Explica 'combination sum II' sin repetición.", "response": "Similar, pero avanza índice y salta duplicados en el mismo nivel; cada elemento se usa a lo sumo una vez."}
{"instruction": "Explica 'decode ways' DP.", "response": "dp[i] depende de dp[i-1] si s[i] válido (1-9) y dp[i-2] si s[i-1..i] válido (10-26); manejar ceros con cuidado."}
{"instruction": "Explica 'unique binary search trees' (Catalan).", "response": "dp[n]=Σ dp[i-1]*dp[n-i] para i=1..n; números de Catalán; DP O(n^2)."}
{"instruction": "Explica 'interleaving string' DP.", "response": "dp[i][j] verdadero si s3[0..i+j-1] formado por mezcla de s1[0..i-1] y s2[0..j-1]; transiciones por coincidencia de caracteres."}
{"instruction": "Explica 'word break' DP y backtracking.", "response": "DP booleana para verificable; para reconstruir, backtracking con memo guardando cortes válidos; usa trie o set para lookup."}
{"instruction": "Explica 'regular expression matching' DP.", "response": "Patrón con '.' y '*'; dp[i][j] dependiendo si '*' toma 0 o más del char previo; base con patrones que pueden vaciarse."}
{"instruction": "Explica 'wildcard matching' DP y greedy.", "response": "DP clásico; greedy alternativo guardando última '*' y backtracking cuando hay mismatch; más eficiente en práctica."}
{"instruction": "Explica 'burst balloons' DP por intervalos.", "response": "dp[l][r] = max valor al reventar entre (l,r) el último k; valor = dp[l][k]+dp[k][r]+nums[l]*nums[k]*nums[r]; sentinelas."}
{"instruction": "Explica 'matrix chain order' y parentización.", "response": "Guardar punto de corte k además de costo mínimo; reconstruir parentización óptima por recursión desde dp[0][n-1]."}
{"instruction": "Explica 'minimum palindrome cuts' DP.", "response": "dp[i]=mín cortes para s[0..i]; dp[i]=min(dp[j]+1) para j<i y s[j+1..i] palíndromo; base dp[i]=0 si s[0..i] ya palíndromo."}
{"instruction": "Explica 'longest palindromic substring' expand around center.", "response": "Para cada centro (i, i) y (i, i+1), expandir mientras s[l]==s[r]; O(n^2) tiempo, O(1) espacio; simple y efectivo."}
{"instruction": "Explica 'palindromic subsequences' conteo DP.", "response": "dp[i][j] = dp[i+1][j] + dp[i][j-1] + (1 si s[i]==s[j]) - dp[i+1][j-1]; modular por tamaño; cuidado con dobles conteos."}
{"instruction": "Explica 'balanced parentheses mínimo removals'.", "response": "Usar conteo para detectar excesos de ')' y pila/contadores para '('; o BFS por niveles eliminando un paréntesis y probando validez."}
{"instruction": "Explica 'longest valid parentheses'.", "response": "Pila de índices o DP; con pila, push -1 al inicio; al ver ')', pop; si vacía, push índice; si no, max con i - top()."}
{"instruction": "Explica 'merge k sorted lists' y por qué heap.", "response": "Heap mínimo con cabezas de listas; extrae y push siguiente; O(n log k) donde n total de nodos; mejor que merge secuencial."}
{"instruction": "Explica 'reorder list' (L0→Ln→L1→Ln-1...).", "response": "Hallar mitad con slow/fast, invertir segunda mitad, intercalar nodos; O(n) tiempo y O(1) extra."}
{"instruction": "Explica 'clone graph' con hash map.", "response": "DFS/BFS copiando nodos y guardando mapeo original→copia; al visitar vecinos, enlazar usando el map; evita duplicados/ciclos."}
{"instruction": "Explica 'course schedule II' orden topológico resultado.", "response": "Tras Kahn/DFS, devolver orden obtenido si no hay ciclo; si hay ciclo, devolver vacío; validar tamaño == V."}
{"instruction": "Explica 'Pacific Atlantic water flow' BFS/DFS inversa.", "response": "Iniciar desde costas Pacífico y Atlántico y marcar alcanzables inversamente; intersección da celdas que fluyen a ambos."}
{"instruction": "Explica 'rotten oranges' BFS multi-fuente.", "response": "Encolar todas las naranjas podridas con tiempo 0; expandir a frescas y contar minutos; si quedan frescas sin visitar, -1."}
{"instruction": "Explica 'surrounded regions' (board) con DFS desde bordes.", "response": "Marcar 'O' conectadas a borde como seguras; luego convertir el resto a 'X'; finalmente restaurar seguras; evita capturar borde."}
{"instruction": "Explica 'number of islands' variación con diagonales.", "response": "Cambiar vecindad a 8 direcciones; BFS/DFS con 8 vecinos; cuenta componentes conectados considerando diagonales."}
{"instruction": "Explica 'walls and gates' BFS multi-fuente.", "response": "Encolar todas las puertas (0) y expandir calculando distancias mínimas en celdas INF; paredes (-1) bloquean; O(R·C)."}
{"instruction": "Explica 'word search II' optimización con podas.", "response": "Usar trie y eliminar nodos hoja tras encontrar palabra (pruning); corta ramas inútiles y mejora tiempo."}
{"instruction": "Explica 'LRU cache' errores comunes.", "response": "No actualizar posición en get; olvidar eliminar nodo en borrar; mal manejo de punteros en extremos; usar sentinelas simplifica."}
{"instruction": "Explica 'LFU cache' idea.", "response": "Hash key→(val,freq) y map freq→lista de keys en LRU; minfreq para expulsar; O(1) amortizado para get/put con estructuras cuidadas."}
{"instruction": "Explica 'binary search tree iterator' en-order.", "response": "Pila para desplazar al más izquierdo; next devuelve actual y baja por derecha; hasNext mientras pila no vacía; O(h) espacio."}
{"instruction": "Explica 'serialize N-ary tree' por nivel.", "response": "Guardar número de hijos por nodo junto a valor; deserializar leyendo conteos; o usar separadores por nivel; múltiples esquemas válidos."}
{"instruction": "Explica 'k closest points to origin' con heap.", "response": "Heap máximo de tamaño k con dist^2; mantener top-k más cercanos; O(n log k) tiempo; evitar sqrt."}
{"instruction": "Explica 'top k frequent words' desempate lexicográfico.", "response": "Heap con comparador por frecuencia desc y palabra asc; o contar y ordenar; importante criterio de desempate consistente."}
{"instruction": "Explica 'task scheduler' (intervalos de cooldown).", "response": "Uso de conteos y fórmula de huecos: max(len, (maxCount-1)*(n+1)+numMax); o simular con heap; elegir según necesidad."}
{"instruction": "Explica 'hand of straights' con greedy y mapa frecuencias.", "response": "Ordenar keys, para cada valor usarlo como inicio usando k consecutivos decrementando conteos; si faltan, imposible."}
{"instruction": "Explica 'split array largest sum' con binaria en respuesta.", "response": "Buscar mínimo mayor suma permitida para dividir en m subarreglos; verificación lineal acumulando y cortando cuando supera C."}
{"instruction": "Explica 'find median from data stream' dos heaps.", "response": "Mantener heaps balanceados; insertar y rebalancear; mediana es top del mayor o promedio de ambos; O(log n) por inserción."}
{"instruction": "Explica 'design hit counter' con cola circular.", "response": "Guardar timestamps agregando conteos por segundo y limpiar fuera de ventana (300s); sumar al consultar; O(1) amortizado."}
{"instruction": "Explica 'random pick with weight' prefix + binaria.", "response": "Construir prefijos acumulados y bsearch sobre un número aleatorio en [1..sum]; probabilidad proporcional al peso."}
{"instruction": "Explica 'median of data stream' con orden estadístico.", "response": "Alternativa con order-statistics tree para soportar deletes; más complejo; heaps son suficientes si no hay borrados."}
