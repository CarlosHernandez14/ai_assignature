{"instruction": "Explica 'rotate image' (matriz NxN).", "response": "Transponer y luego invertir cada fila (o capas por anillos); O(n^2) tiempo, in-place."}
{"instruction": "Explica selección de actividades (interval scheduling) con greedy.", "response": "Enfoque: Ordenar por tiempo de finalización y seleccionar intervalos compatibles. | Pasos: Ordena por fin; toma el primero; toma el siguiente que empiece después del fin actual; repite. | Correctitud: Prueba de intercambio. | Complejidad: O(n log n)."}
{"instruction": "Explica DP de edición con costo de operaciones diferentes.", "response": "La transición general: min(deleción + cost_del, inserción + cost_ins, sustitución + cost_sub), con una matriz dp; basta ajustar los costos por operación."}
{"instruction": "Analiza la complejidad de un doble bucle anidado i en [0..n) y j en [0..i).", "response": "Conteo de iteraciones: Suma de 0+1+...+(n-1)=n(n-1)/2. | Complejidad: O(n^2). | Espacio: O(1) si no hay estructuras adicionales. | Observación: Triángulo inferior de la matriz de iteraciones."}
{"instruction": "Explica 'word ladder' con BFS bidireccional.", "response": "BFS desde inicio y fin, expandiendo la frontera más pequeña; genera patrones con comodines para vecinos; mejora sobre BFS simple."}
{"instruction": "Explica 'bipartite matching' como flujo.", "response": "Modelar bipartito con fuente conectada a U y V al sumidero, capacidades 1; matching máximo = flujo máximo. | Integridad por capacidades enteras."}
{"instruction": "Explica el algoritmo de Prim para MST.", "response": "Definición: Construye un árbol de expansión mínima agregando la arista más barata que conecta un nuevo vértice al conjunto. | Pasos: Inicia en un vértice; usa un heap por corte de aristas mínimas; añade el menor costo que expande. | Complejidad: O(E log V) con heap. | Comparación: Similar objetivo a Kruskal, distinto enfoque."}
{"instruction": "Explica por qué el teorema maestro no aplica siempre.", "response": "Limitaciones: Requiere subproblemas del mismo tamaño y particiones regulares; f(n) polinomialmente relacionada con n^{log_b a}. | Casos no cubiertos: Subproblemas de tamaños distintos, recursiones no uniformes, f(n) irregular. | Alternativas: Recursión Akra–Bazzi."}
{"instruction": "Discute dos módulos y dos bases para reducir colisiones en Rabin-Karp.", "response": "Usar doble hash con distintos primos y bases minimiza probabilidad de colisiones coincidentes; verifica ambos antes de confirmar match."}
{"instruction": "Explica 'meet-in-the-middle' en subset sum.", "response": "Divide conjunto en dos mitades, genera sumas de cada mitad, ordena una y busca complementos por binaria; O(2^(n/2) log). | Útil para n≈40."}
{"instruction": "Explica el algoritmo Z y su utilidad.", "response": "Definición: Arreglo Z[i] = mayor coincidencia del prefijo empezando en i. | Construcción: Mantiene ventana [l,r] de coincidencias y la reutiliza. | Uso: Búsqueda de patrones, coincidencias repetidas. | Complejidad: O(n). | Comparación: Similar objetivo a KMP con otra tabla."}
{"instruction": "Define grafo bipartito y un criterio con matching máximo.", "response": "Un grafo es bipartito si no tiene ciclos impares; además, König: tamaño del matching máximo = tamaño del vertex cover mínimo en bipartitos."}
{"instruction": "Explica 'walls and gates' BFS multi-fuente.", "response": "Encolar todas las puertas (0) y expandir calculando distancias mínimas en celdas INF; paredes (-1) bloquean; O(R·C)."}
{"instruction": "Explica 'top k frequent words' desempate lexicográfico.", "response": "Heap con comparador por frecuencia desc y palabra asc; o contar y ordenar; importante criterio de desempate consistente."}
{"instruction": "Explica edición con transposición (Damerau-Levenshtein).", "response": "Permite operaciones de inserción, borrado, sustitución y transposición de adyacentes; DP ampliada con memoria de posiciones. | Útil en corrección tipográfica."}
{"instruction": "Explica el algoritmo de multiplicación rápida (exponenciación binaria).", "response": "Idea: Expresar exponente en binario; si bit=1, multiplica al acumulador; cada paso, cuadrar base y desplazar exponente. | Complejidad: O(log e). | Uso: Potencias grandes modulares. | Errores: Desbordes si no usas módulo."}
{"instruction": "Demuestra el coste de build-heap sobre un arreglo.", "response": "Hecho: Build-heap por heapify desde n/2 hasta 1 cuesta O(n). | Intuición: Pocos nodos profundos tienen costos altos pero su número decrece; suma geométrica domina por n. | Resultado: Heapsort O(n log n) tras O(n) de construcción."}
{"instruction": "Explica 'Pacific Atlantic water flow' BFS/DFS inversa.", "response": "Iniciar desde costas Pacífico y Atlántico y marcar alcanzables inversamente; intersección da celdas que fluyen a ambos."}
{"instruction": "Explica puentes en grafos y su detección.", "response": "Arista (u,v) es puente si low[v] > tin[u] en DFS; al eliminarla, aumenta componentes. | Se calcula en O(V+E)."}
{"instruction": "Explica 'LFU cache' idea.", "response": "Hash key→(val,freq) y map freq→lista de keys en LRU; minfreq para expulsar; O(1) amortizado para get/put con estructuras cuidadas."}
{"instruction": "Compara ordenamientos in-place y no in-place.", "response": "In-place: Usa O(1) espacio adicional (quicksort típico). | No in-place: Requiere espacio extra (mergesort clásico O(n)). | Impacto: Memoria y caché; in-place ahorra memoria pero puede ser más complejo. | Elección: Según restricciones."}
{"instruction": "Describe el algoritmo de inserción y sus ventajas sobre burbuja.", "response": "Definición: Inserción construye un arreglo ordenado insertando cada elemento en su posición en la porción izquierda. | Ventajas: Funciona muy bien con datos casi ordenados y es estable. | Pasos: Para i de 1..n-1, guarda key=arr[i], desplaza elementos mayores a la derecha, inserta key. | Ejemplo: [3,1,2]→coloca 1 antes de 3→[1,3,2]→coloca 2 entre 1 y 3→[1,2,3]. | Complejidad: Promedio/peor O(n^2); mejor O(n) si casi ordenado. | Estable: Sí."}
{"instruction": "Traza una pasada de Kahn en un DAG simple y muestra el orden resultante.", "response": "Ejemplo: A→B, A→C, B→D, C→D. | In-degree: A=0,B=1,C=1,D=2. | Cola inicial: [A]; saca A→decrementa B,C→0→[B,C]; saca B→D=1; saca C→D=0→[D]; saca D. | Orden: A, B, C, D (o A,C,B,D)."}
{"instruction": "Explica 'decode ways' DP.", "response": "dp[i] depende de dp[i-1] si s[i] válido (1-9) y dp[i-2] si s[i-1..i] válido (10-26); manejar ceros con cuidado."}
{"instruction": "Explica por qué 'median of two sorted arrays' requiere partición válida.", "response": "Condición max(leftA,leftB) ≤ min(rightA,rightB); garantiza que la mediana está en los bordes de la partición combinada."}
{"instruction": "Explica el patrón de dos pilas para implementar una cola.", "response": "Idea: Pila de entrada para enqueue y pila de salida para dequeue; al vaciar salida, volcar entrada a salida invirtiendo orden. | Complejidad: Amortizada O(1) por operación. | Errores: No volcar solo cuando salida esté vacía."}
{"instruction": "Explica por qué 'probing lineal' requiere factor de carga controlado.", "response": "Clustering primario degrada rendimiento a medida que la tabla se llena; mantener load factor < 0.7 y usar doble hashing/quadratic ayuda."}
{"instruction": "Explica 'median of data stream' con orden estadístico.", "response": "Alternativa con order-statistics tree para soportar deletes; más complejo; heaps son suficientes si no hay borrados."}
{"instruction": "Diseña un algoritmo para detectar un ciclo en grafo no dirigido.", "response": "Método DFS: Pasar nodo padre en la recursión; si encuentras vecino visitado distinto de padre, hay ciclo. | Alternativa: Union-Find detecta ciclo al intentar unir dos vértices ya conectados. | Complejidad: O(V+E)."}
{"instruction": "Explica 'permutations II' (con duplicados) backtracking.", "response": "Usar contador de ocurrencias por valor; elegir valores con count>0, decrementar y backtrack; evita duplicados naturalmente."}
{"instruction": "Explica qué es un trie y un caso de uso típico.", "response": "Definición: Árbol de prefijos para cadenas donde cada nodo representa un prefijo. | Operaciones: insertar, buscar, borrar, listar por prefijo. | Uso: Autocompletado y verificación de diccionarios. | Complejidad: O(L) por operación donde L es longitud de la palabra. | Espacio: Alto si no se comprime; mitigable con punteros compactos o DAWG."}
{"instruction": "Explica 'minimum palindrome cuts' DP.", "response": "dp[i]=mín cortes para s[0..i]; dp[i]=min(dp[j]+1) para j<i y s[j+1..i] palíndromo; base dp[i]=0 si s[0..i] ya palíndromo."}
{"instruction": "Explica 'offline range add + point query' con diferencia y prefix.", "response": "Aplicar todas actualizaciones a un diff y luego hacer prefijos; para queries puntuales, basta leer prefijo en la posición."}
{"instruction": "Explica por qué el algoritmo de Kruskal produce un MST.", "response": "Justificación: Propiedad del corte: la arista mínima que cruza cualquier corte pertenece a algún MST; Kruskal siempre escoge aristas mínimas que no forman ciclos; así construye un árbol válido y mínimo. | Correctitud: Prueba por intercambio y propiedad de corte."}
