{"instruction": "Diseña un chequeo de palíndromo ignorando no alfanuméricos.", "response": "Enfoque: Dos punteros sobre la cadena; avanza hasta caracteres alfanuméricos; compara case-insensitive; si difiere, no palíndromo; si cruzan, sí. | Complejidad: O(n)."}
{"instruction": "Explica la resolución de sudokus por backtracking.", "response": "Idea: Buscar celda vacía, intentar dígitos válidos (sin repetir en fila, columna, subcuadro); recursar; si no hay opción, retroceder. | Poda: Ordenar por celda más restringida (MRV) acelera. | Complejidad: Exponencial en peor caso; práctica: rápido con buenas podas."}
{"instruction": "¿Qué es un AVL y qué garantiza?", "response": "Definición: BST auto-balanceado que asegura que las alturas de subárboles difieran a lo sumo en 1. | Garantía: Operaciones O(log n) en peor caso. | Mecanismo: Rotaciones simples y dobles tras inserciones/borrados. | Uso: Cuando la peor cota O(log n) debe mantenerse. | Desventaja: Constantes mayores que BST simple."}
{"instruction": "Resume los árboles rojo-negro y su objetivo.", "response": "Definición: BST balanceado con reglas de coloración que limitan la altura. | Objetivo: Mantener O(log n) garantizado para operaciones básicas. | Reglas: Nodo rojo no puede tener hijo rojo; todo camino a hojas nulas tiene igual número de negros. | Ventaja: Buen rendimiento en práctica; se usa en librerías estándar."}
{"instruction": "Explica 'order statistics tree' y operaciones.", "response": "BST balanceado con tamaño de subárbol para seleccionar k-ésimo o rank; soporta insert/borrar/buscar/rank/select en O(log n)."}
{"instruction": "Explica 'interleaving string' DP.", "response": "dp[i][j] verdadero si s3[0..i+j-1] formado por mezcla de s1[0..i-1] y s2[0..j-1]; transiciones por coincidencia de caracteres."}
{"instruction": "Resuelve N-Reinas (N=4) con backtracking y explica la poda.", "response": "Enfoque: Colocar reinas fila por fila evitando columnas y diagonales ocupadas. | Poda: Si una posición ataca o es atacada, no seguir; usar conjuntos para col, diag1, diag2. | Soluciones N=4: [1,3,0,2] y [2,0,3,1]. | Complejidad: Exponencial, mitigada por poda."}
{"instruction": "Explica 'serialize/deserialize' por preorden con marcadores.", "response": "Preorden incluyendo marcadores '#' para null; deserializar leyendo secuencia recursivamente; reconstruye estructura exacta."}
{"instruction": "Explica el concepto de colisiones en hashing y cómo mitigarlas.", "response": "Colisión: Dos claves mapean al mismo índice. | Mitigación: Buen hash con distribución uniforme; redimensionar al superar factor de carga; chaining con listas o open addressing bien parametrizado; verificación de igualdad tras hash. | Práctica: Usa primos en tamaño y doble hashing."}
{"instruction": "Explica Big-O, Big-Theta y Big-Omega con ejemplos.", "response": "Big-O: Cota superior asintótica (f(n)∈O(n^2)). | Big-Ω: Cota inferior (f(n)∈Ω(n)). | Big-Θ: Cota ajustada (f(n)∈Θ(n log n)). | Ejemplo: Mergesort es Θ(n log n); inserción es O(n^2) y Ω(n). | Uso: Comparar crecimiento de costes."}
{"instruction": "Explica por qué BFS encuentra la ruta más corta en grafos no ponderados.", "response": "Razón: BFS explora por capas de distancia creciente; la primera vez que visitas un nodo es por el camino con menos aristas. | Demostración: Inducción por capa. | Restricción: Pesos unitarios o iguales."}
{"instruction": "Explica el patrón dos pilas para evaluar expresiones infijas (idea).", "response": "Idea: Pilas de operandos y operadores; manejar precedencia y paréntesis: al ver operador, desapilar operadores de mayor/igual precedencia y aplicarlos; push nuevo operador; al final, vaciar. | Complejidad: O(n). | Cuidado: Precedencia y asociatividad."}
{"instruction": "Explica la diferencia entre BFS con lista de adyacencia y matriz en densidad distinta.", "response": "Lista: Recorrer vecinos reales, O(grado). | Matriz: Revisar todas las columnas, O(V). | Grafos dispersos: lista es más eficiente; densos: matriz puede ser aceptable. | Complejidad total: O(V+E) vs O(V^2)."}
{"instruction": "¿Cómo funciona una tabla hash y qué estrategias hay contra colisiones?", "response": "Idea: Aplica una función hash a la clave para ubicar un bucket donde se almacena el par clave-valor. | Colisiones: chaining (listas por bucket) o open addressing (lineal, cuadrática, doble hash). | Complejidad: Promedio O(1) para insertar/buscar; peor O(n). | Errores: No redimensionar al superar factor de carga; mala función hash."}
{"instruction": "Corrige un error típico en búsqueda binaria que produce bucle infinito.", "response": "Problema: Actualizar mal low/high, p. ej., usar mid en ambos extremos. | Corrección: Cuando arr[mid]<target, low=mid+1; cuando >target, high=mid-1; recalcula mid cada vez. | Asegurar condición: while low<=high. | Verificar overflow: mid=low+(high-low)/2."}
{"instruction": "Explica 'k closest points to origin' con heap.", "response": "Heap máximo de tamaño k con dist^2; mantener top-k más cercanos; O(n log k) tiempo; evitar sqrt."}
